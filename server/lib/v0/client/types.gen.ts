// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseUrl: 'https://api.v0.dev/v1' | (string & {});
};

/**
 * Detailed representation of a chat, including its messages, files, versions, and model configuration.
 */
export type ChatDetail = {
    /**
     * A unique identifier for the chat.
     */
    id: string;
    /**
     * Fixed value identifying this object as a chat.
     */
    object: 'chat';
    /**
     * Indicates whether the chat can be shared via public link.
     */
    shareable: boolean;
    /**
     * Defines the visibility of the chat—private, team-only, or public.
     */
    privacy: 'public' | 'private' | 'team' | 'team-edit' | 'unlisted';
    /**
     * An optional name assigned to the chat by the user.
     */
    name?: string;
    /**
     * Deprecated title field preserved for backward compatibility.
     * @deprecated
     */
    title?: string;
    /**
     * The ISO timestamp representing when the chat was created.
     */
    createdAt: string;
    /**
     * The ISO timestamp of the last update to the chat.
     */
    updatedAt?: string;
    /**
     * Indicates whether the chat is marked as a favorite.
     */
    favorite: boolean;
    /**
     * The ID of the user who created the chat.
     */
    authorId: string;
    /**
     * Optional ID of the v0 project associated with this chat.
     */
    projectId?: string;
    /**
     * Web URL to view this chat in the browser.
     */
    webUrl: string;
    /**
     * API URL to access this chat via the API.
     */
    apiUrl: string;
    /**
     * Full details of the most recent generated version, if available.
     */
    latestVersion?: {
        /**
         * A unique identifier for the version.
         */
        id: string;
        /**
         * Fixed value identifying this object as a version.
         */
        object: 'version';
        /**
         * The current status of the version generation process.
         */
        status: 'pending' | 'completed' | 'failed';
        /**
         * Optional URL for previewing the generated output.
         */
        demoUrl?: string;
        /**
         * The date and time when the version was created, in ISO 8601 format.
         */
        createdAt: string;
        /**
         * The date and time when the version was last updated, in ISO 8601 format.
         */
        updatedAt?: string;
        /**
         * A list of files that were generated or included in this version.
         */
        files: Array<{
            /**
             * Fixed value identifying this object as a file.
             */
            object: 'file';
            /**
             * The name of the file, including its extension.
             */
            name: string;
            /**
             * The full contents of the file as a raw string.
             */
            content: string;
            /**
             * Whether the file is locked to prevent AI from overwriting it during new version generation.
             */
            locked: boolean;
        }>;
        /**
         * URL to retrieve a screenshot of this version.
         */
        screenshotUrl?: string;
    };
    /**
     * The canonical URL to access this chat.
     * @deprecated
     */
    url: string;
    /**
     * All messages exchanged in the chat, including user and assistant entries.
     */
    messages: Array<{
        /**
         * A unique identifier for the message.
         */
        id: string;
        /**
         * Fixed value identifying this object as a message.
         */
        object: 'message';
        /**
         * The main text content of the message.
         */
        content: string;
        /**
         * The parsed content of the message as an array structure containing AST nodes. This is an experimental field that may change.
         */
        experimental_content?: Array<[
            unknown,
            unknown
        ] | [
            unknown,
            unknown
        ]>;
        /**
         * The ISO timestamp representing when the message was created.
         */
        createdAt: string;
        /**
         * The ISO timestamp representing when the message was last updated.
         */
        updatedAt?: string;
        /**
         * Indicates the format or category of the message, such as plain text or code.
         */
        type: 'message' | 'forked-block' | 'forked-chat' | 'open-in-v0' | 'refinement' | 'added-environment-variables' | 'added-integration' | 'deleted-file' | 'moved-file' | 'renamed-file' | 'edited-file' | 'replace-src' | 'reverted-block' | 'fix-with-v0' | 'auto-fix-with-v0' | 'sync-git';
        /**
         * Specifies whether the message was sent by the user or the assistant.
         */
        role: 'user' | 'assistant';
        /**
         * The reason why the message generation finished.
         */
        finishReason?: 'stop' | 'length' | 'content-filter' | 'tool-calls' | 'error' | 'other' | 'unknown';
        /**
         * API URL to access this message via the API.
         */
        apiUrl: string;
        /**
         * The ID of the user who sent the message.
         */
        authorId: string | null;
        /**
         * The ID of the parent message.
         */
        parentId?: string | null;
        attachments?: Array<{
            /**
             * The URL where the attachment file can be accessed.
             */
            url: string;
            /**
             * The original filename of the attachment.
             */
            name?: string;
            /**
             * The MIME type of the attachment file (e.g., image/png, application/pdf).
             */
            contentType?: string;
            /**
             * The size of the attachment file in bytes.
             */
            size: number;
            /**
             * The base64-encoded content of the attachment file, if available.
             */
            content?: string;
            /**
             * Optional v0-specific attachment type for enhanced processing.
             */
            type?: 'screenshot' | 'figma' | 'zip';
        }>;
    }>;
    /**
     * Optional array of files associated with the chat context.
     */
    files?: Array<{
        /**
         * Programming language used in the file (e.g., JavaScript, Python).
         */
        lang: string;
        /**
         * A key-value map of metadata associated with the file (e.g., path, type).
         */
        meta: {
            [key: string]: string;
        };
        /**
         * The origin or identifier of the file source (e.g., path or upload label).
         */
        source: string;
    }>;
    /**
     * Deprecated demo URL used for previewing the chat result.
     * @deprecated
     */
    demo?: string;
    /**
     * The main user prompt or instruction that started the chat.
     */
    text: string;
    /**
     * The configuration used to generate responses in this chat.
     */
    modelConfiguration?: {
        /**
         * Deprecated Model ID field preserved for backward compatibility.
         * @deprecated
         */
        modelId?: 'v0-1.5-sm' | 'v0-1.5-md' | 'v0-1.5-lg' | 'v0-gpt-5';
        /**
         * Enables image generations to generate up to 5 images per version.
         */
        imageGenerations?: boolean;
        /**
         * Enables thinking to generate a response in multiple steps.
         */
        thinking?: boolean;
    };
    permissions: {
        /**
         * If true, the user has write access to the chat.
         */
        write: boolean;
    };
};

/**
 * Summary of a chat, including metadata like privacy, author, latest version, and URLs.
 */
export type ChatSummary = {
    /**
     * A unique identifier for the chat.
     */
    id: string;
    /**
     * Fixed value identifying this object as a chat.
     */
    object: 'chat';
    /**
     * Indicates whether the chat can be shared via public link.
     */
    shareable: boolean;
    /**
     * Defines the visibility of the chat—private, team-only, or public.
     */
    privacy: 'public' | 'private' | 'team' | 'team-edit' | 'unlisted';
    /**
     * An optional name assigned to the chat by the user.
     */
    name?: string;
    /**
     * Deprecated title field preserved for backward compatibility.
     * @deprecated
     */
    title?: string;
    /**
     * The ISO timestamp representing when the chat was created.
     */
    createdAt: string;
    /**
     * The ISO timestamp of the last update to the chat.
     */
    updatedAt?: string;
    /**
     * Indicates whether the chat is marked as a favorite.
     */
    favorite: boolean;
    /**
     * The ID of the user who created the chat.
     */
    authorId: string;
    /**
     * Optional ID of the v0 project associated with this chat.
     */
    projectId?: string;
    /**
     * Web URL to view this chat in the browser.
     */
    webUrl: string;
    /**
     * API URL to access this chat via the API.
     */
    apiUrl: string;
    /**
     * The most recent generated version of the chat, if available.
     */
    latestVersion?: {
        /**
         * A unique identifier for the version.
         */
        id: string;
        /**
         * Fixed value identifying this object as a version.
         */
        object: 'version';
        /**
         * The current status of the version generation process.
         */
        status: 'pending' | 'completed' | 'failed';
        /**
         * Optional URL for previewing the generated output.
         */
        demoUrl?: string;
        /**
         * The date and time when the version was created, in ISO 8601 format.
         */
        createdAt: string;
        /**
         * The date and time when the version was last updated, in ISO 8601 format.
         */
        updatedAt?: string;
    };
};

export type DeploymentDetail = {
    /**
     * A unique identifier for the deployment.
     */
    id: string;
    /**
     * Fixed value identifying this object as a deployment.
     */
    object: 'deployment';
    /**
     * URL to the deployment inspector.
     */
    inspectorUrl: string;
    /**
     * The ID of the chat that this deployment is scoped to.
     */
    chatId: string;
    /**
     * The ID of the project that this deployment is scoped to.
     */
    projectId: string;
    /**
     * The ID of the version that this deployment is scoped to.
     */
    versionId: string;
    /**
     * The API endpoint URL for accessing this deployment programmatically.
     */
    apiUrl: string;
    /**
     * The web URL where the deployment can be viewed or managed.
     */
    webUrl: string;
};

export type DeploymentSummary = {
    /**
     * A unique identifier for the deployment.
     */
    id: string;
    /**
     * Fixed value identifying this object as a deployment.
     */
    object: 'deployment';
    /**
     * URL to the deployment inspector.
     */
    inspectorUrl: string;
    /**
     * The ID of the chat that this deployment is scoped to.
     */
    chatId: string;
    /**
     * The ID of the project that this deployment is scoped to.
     */
    projectId: string;
    /**
     * The ID of the version that this deployment is scoped to.
     */
    versionId: string;
    /**
     * The API endpoint URL for accessing this deployment programmatically.
     */
    apiUrl: string;
    /**
     * The web URL where the deployment can be viewed or managed.
     */
    webUrl: string;
};

/**
 * Detailed information for an environment variable including its value.
 */
export type EnvironmentVariableDetailSchema = {
    /**
     * A unique identifier for the environment variable.
     */
    id: string;
    /**
     * The object type.
     */
    object: 'environment_variable';
    /**
     * The name of the environment variable.
     */
    key: string;
    /**
     * The value of the environment variable.
     */
    value: string;
    /**
     * Whether the value is decrypted or encrypted.
     */
    decrypted: boolean;
    /**
     * The timestamp when the environment variable was created.
     */
    createdAt: number;
    /**
     * The timestamp when the environment variable was last updated.
     */
    updatedAt?: number;
};

/**
 * Summary information for an environment variable.
 */
export type EnvironmentVariableSummarySchema = {
    /**
     * A unique identifier for the environment variable.
     */
    id: string;
    /**
     * The object type.
     */
    object: 'environment_variable';
    /**
     * The name of the environment variable.
     */
    key: string;
    /**
     * The value of the environment variable.
     */
    value: string;
    /**
     * Whether the value is decrypted or encrypted.
     */
    decrypted: boolean;
    /**
     * The timestamp when the environment variable was created.
     */
    createdAt: number;
    /**
     * The timestamp when the environment variable was last updated.
     */
    updatedAt?: number;
};

/**
 * List response containing environment variables.
 */
export type EnvironmentVariablesListSchema = {
    /**
     * Fixed value identifying this as a list response.
     */
    object: 'list';
    /**
     * Array of environment variable details.
     */
    data: Array<{
        /**
         * A unique identifier for the environment variable.
         */
        id: string;
        /**
         * The object type.
         */
        object: 'environment_variable';
        /**
         * The name of the environment variable.
         */
        key: string;
        /**
         * The value of the environment variable.
         */
        value: string;
        /**
         * Whether the value is decrypted or encrypted.
         */
        decrypted: boolean;
        /**
         * The timestamp when the environment variable was created.
         */
        createdAt: number;
        /**
         * The timestamp when the environment variable was last updated.
         */
        updatedAt?: number;
    }>;
};

/**
 * Detailed representation of a file, including its content and lock status.
 */
export type FileDetail = {
    /**
     * Fixed value identifying this object as a file.
     */
    object: 'file';
    /**
     * The name of the file, including its extension.
     */
    name: string;
    /**
     * The full contents of the file as a raw string.
     */
    content: string;
    /**
     * Whether the file is locked to prevent AI from overwriting it during new version generation.
     */
    locked: boolean;
};

/**
 * Basic metadata about a file, such as its type and name.
 */
export type FileSummary = {
    /**
     * Fixed value identifying this object as a file.
     */
    object: 'file';
    /**
     * The name of the file, including its extension.
     */
    name: string;
};

/**
 * Full configuration details for a webhook, including its scope and subscription.
 */
export type HookDetail = {
    /**
     * A unique identifier for the webhook.
     */
    id: string;
    /**
     * Fixed value identifying this object as a webhook.
     */
    object: 'hook';
    /**
     * A user-defined name to label the webhook.
     */
    name: string;
    /**
     * List of event types this webhook is subscribed to.
     */
    events: Array<'chat.created' | 'chat.updated' | 'chat.deleted' | 'message.created' | 'message.updated' | 'message.deleted' | 'message.finished'>;
    /**
     * Optional ID of the chat that this webhook is scoped to.
     */
    chatId?: string;
    /**
     * Target URL that receives event payloads for this webhook.
     */
    url: string;
};

/**
 * Detailed record of a webhook event, including its type, status, and timestamp.
 */
export type HookEventDetail = {
    /**
     * A unique identifier for the webhook event log entry.
     */
    id: string;
    /**
     * Fixed value identifying this object as a webhook event.
     */
    object: 'hook_event';
    /**
     * The type of event that triggered the webhook.
     */
    event: 'chat.created' | 'chat.updated' | 'chat.deleted' | 'message.created' | 'message.updated' | 'message.deleted' | 'message.finished';
    /**
     * The delivery status of the webhook (e.g., delivered, failed).
     */
    status?: 'pending' | 'success' | 'error';
    /**
     * Timestamp of when the webhook event was triggered.
     */
    createdAt: string;
};

/**
 * Summary of a webhook, including its ID and display name.
 */
export type HookSummary = {
    /**
     * A unique identifier for the webhook.
     */
    id: string;
    /**
     * Fixed value identifying this object as a webhook.
     */
    object: 'hook';
    /**
     * A user-defined name to label the webhook.
     */
    name: string;
};

/**
 * Detailed information about an integration connection to a project.
 */
export type IntegrationConnectionDetailSchema = {
    /**
     * The object type.
     */
    object: 'integration_connection';
    /**
     * The unique ID of the integration connection (format: {projectId}_{integrationId}).
     */
    id: string;
    /**
     * Whether the integration is connected to the project.
     */
    connected: boolean;
    /**
     * Information about the connected integration.
     */
    integration: {
        /**
         * The ID of the integration.
         */
        id: string;
        /**
         * The object type.
         */
        object: 'integration';
        /**
         * The slug of the integration.
         */
        slug: string;
        /**
         * The name of the integration.
         */
        name: string;
    };
    /**
     * Additional metadata about the integration connection.
     */
    metadata?: {
        [key: string]: unknown;
    };
};

/**
 * List response containing integration connections.
 */
export type IntegrationConnectionListSchema = {
    /**
     * Fixed value identifying this as a list response.
     */
    object: 'list';
    /**
     * Array of integration connection summaries.
     */
    data: Array<{
        /**
         * The object type.
         */
        object: 'integration_connection';
        /**
         * The unique ID of the integration connection (format: {projectId}_{integrationId}).
         */
        id: string;
        /**
         * Whether the integration is connected to the project.
         */
        connected: boolean;
        /**
         * Information about the connected integration.
         */
        integration: {
            /**
             * The ID of the integration.
             */
            id: string;
            /**
             * The object type.
             */
            object: 'integration';
            /**
             * The slug of the integration.
             */
            slug: string;
            /**
             * The name of the integration.
             */
            name: string;
        };
    }>;
};

/**
 * Summary information about an integration connection to a project.
 */
export type IntegrationConnectionSummarySchema = {
    /**
     * The object type.
     */
    object: 'integration_connection';
    /**
     * The unique ID of the integration connection (format: {projectId}_{integrationId}).
     */
    id: string;
    /**
     * Whether the integration is connected to the project.
     */
    connected: boolean;
    /**
     * Information about the connected integration.
     */
    integration: {
        /**
         * The ID of the integration.
         */
        id: string;
        /**
         * The object type.
         */
        object: 'integration';
        /**
         * The slug of the integration.
         */
        slug: string;
        /**
         * The name of the integration.
         */
        name: string;
    };
};

/**
 * Detailed information about an integration.
 */
export type IntegrationDetailSchema = {
    /**
     * The ID of the integration.
     */
    id: string;
    /**
     * The object type.
     */
    object: 'integration';
    /**
     * The slug of the integration.
     */
    slug: string;
    /**
     * The name of the integration.
     */
    name: string;
    /**
     * A short description of the integration.
     */
    description: string;
    /**
     * URL to the integration icon.
     */
    iconUrl: string;
};

/**
 * List of available integrations.
 */
export type IntegrationListSchema = {
    /**
     * Fixed value identifying this as a list response.
     */
    object: 'list';
    /**
     * Array of integration details.
     */
    data: Array<{
        /**
         * The ID of the integration.
         */
        id: string;
        /**
         * The object type.
         */
        object: 'integration';
        /**
         * The slug of the integration.
         */
        slug: string;
        /**
         * The name of the integration.
         */
        name: string;
        /**
         * A short description of the integration.
         */
        description: string;
        /**
         * URL to the integration icon.
         */
        iconUrl: string;
    }>;
};

/**
 * Basic information about an integration.
 */
export type IntegrationSummarySchema = {
    /**
     * The ID of the integration.
     */
    id: string;
    /**
     * The object type.
     */
    object: 'integration';
    /**
     * The slug of the integration.
     */
    slug: string;
    /**
     * The name of the integration.
     */
    name: string;
};

/**
 * Detailed message object extending MessageSummary with chat metadata.
 */
export type MessageDetail = {
    /**
     * A unique identifier for the message.
     */
    id: string;
    /**
     * Fixed value identifying this object as a message.
     */
    object: 'message';
    /**
     * The main text content of the message.
     */
    content: string;
    /**
     * The parsed content of the message as an array structure containing AST nodes. This is an experimental field that may change.
     */
    experimental_content?: Array<[
        unknown,
        unknown
    ] | [
        unknown,
        unknown
    ]>;
    /**
     * The ISO timestamp representing when the message was created.
     */
    createdAt: string;
    /**
     * The ISO timestamp representing when the message was last updated.
     */
    updatedAt?: string;
    /**
     * Indicates the format or category of the message, such as plain text or code.
     */
    type: 'message' | 'forked-block' | 'forked-chat' | 'open-in-v0' | 'refinement' | 'added-environment-variables' | 'added-integration' | 'deleted-file' | 'moved-file' | 'renamed-file' | 'edited-file' | 'replace-src' | 'reverted-block' | 'fix-with-v0' | 'auto-fix-with-v0' | 'sync-git';
    /**
     * Specifies whether the message was sent by the user or the assistant.
     */
    role: 'user' | 'assistant';
    /**
     * The reason why the message generation finished.
     */
    finishReason?: 'stop' | 'length' | 'content-filter' | 'tool-calls' | 'error' | 'other' | 'unknown';
    /**
     * API URL to access this message via the API.
     */
    apiUrl: string;
    /**
     * The ID of the user who sent the message.
     */
    authorId: string | null;
    /**
     * The ID of the parent message.
     */
    parentId?: string | null;
    attachments?: Array<{
        /**
         * The URL where the attachment file can be accessed.
         */
        url: string;
        /**
         * The original filename of the attachment.
         */
        name?: string;
        /**
         * The MIME type of the attachment file (e.g., image/png, application/pdf).
         */
        contentType?: string;
        /**
         * The size of the attachment file in bytes.
         */
        size: number;
        /**
         * The base64-encoded content of the attachment file, if available.
         */
        content?: string;
        /**
         * Optional v0-specific attachment type for enhanced processing.
         */
        type?: 'screenshot' | 'figma' | 'zip';
    }>;
    /**
     * The ID of the chat to which this message belongs.
     */
    chatId: string;
};

/**
 * Summary of a single message within a chat, including role, content, type, timestamp, and API URL.
 */
export type MessageSummary = {
    /**
     * A unique identifier for the message.
     */
    id: string;
    /**
     * Fixed value identifying this object as a message.
     */
    object: 'message';
    /**
     * The main text content of the message.
     */
    content: string;
    /**
     * The parsed content of the message as an array structure containing AST nodes. This is an experimental field that may change.
     */
    experimental_content?: Array<[
        unknown,
        unknown
    ] | [
        unknown,
        unknown
    ]>;
    /**
     * The ISO timestamp representing when the message was created.
     */
    createdAt: string;
    /**
     * The ISO timestamp representing when the message was last updated.
     */
    updatedAt?: string;
    /**
     * Indicates the format or category of the message, such as plain text or code.
     */
    type: 'message' | 'forked-block' | 'forked-chat' | 'open-in-v0' | 'refinement' | 'added-environment-variables' | 'added-integration' | 'deleted-file' | 'moved-file' | 'renamed-file' | 'edited-file' | 'replace-src' | 'reverted-block' | 'fix-with-v0' | 'auto-fix-with-v0' | 'sync-git';
    /**
     * Specifies whether the message was sent by the user or the assistant.
     */
    role: 'user' | 'assistant';
    /**
     * The reason why the message generation finished.
     */
    finishReason?: 'stop' | 'length' | 'content-filter' | 'tool-calls' | 'error' | 'other' | 'unknown';
    /**
     * API URL to access this message via the API.
     */
    apiUrl: string;
    /**
     * The ID of the user who sent the message.
     */
    authorId: string | null;
    /**
     * The ID of the parent message.
     */
    parentId?: string | null;
    attachments?: Array<{
        /**
         * The URL where the attachment file can be accessed.
         */
        url: string;
        /**
         * The original filename of the attachment.
         */
        name?: string;
        /**
         * The MIME type of the attachment file (e.g., image/png, application/pdf).
         */
        contentType?: string;
        /**
         * The size of the attachment file in bytes.
         */
        size: number;
        /**
         * The base64-encoded content of the attachment file, if available.
         */
        content?: string;
        /**
         * Optional v0-specific attachment type for enhanced processing.
         */
        type?: 'screenshot' | 'figma' | 'zip';
    }>;
};

/**
 * List response containing multiple message summaries with cursor-based pagination.
 */
export type MessageSummaryList = {
    /**
     * Fixed value identifying this as a list response.
     */
    object: 'list';
    /**
     * Array of message summaries in this page of results.
     */
    data: Array<{
        /**
         * A unique identifier for the message.
         */
        id: string;
        /**
         * Fixed value identifying this object as a message.
         */
        object: 'message';
        /**
         * The main text content of the message.
         */
        content: string;
        /**
         * The parsed content of the message as an array structure containing AST nodes. This is an experimental field that may change.
         */
        experimental_content?: Array<[
            unknown,
            unknown
        ] | [
            unknown,
            unknown
        ]>;
        /**
         * The ISO timestamp representing when the message was created.
         */
        createdAt: string;
        /**
         * The ISO timestamp representing when the message was last updated.
         */
        updatedAt?: string;
        /**
         * Indicates the format or category of the message, such as plain text or code.
         */
        type: 'message' | 'forked-block' | 'forked-chat' | 'open-in-v0' | 'refinement' | 'added-environment-variables' | 'added-integration' | 'deleted-file' | 'moved-file' | 'renamed-file' | 'edited-file' | 'replace-src' | 'reverted-block' | 'fix-with-v0' | 'auto-fix-with-v0' | 'sync-git';
        /**
         * Specifies whether the message was sent by the user or the assistant.
         */
        role: 'user' | 'assistant';
        /**
         * The reason why the message generation finished.
         */
        finishReason?: 'stop' | 'length' | 'content-filter' | 'tool-calls' | 'error' | 'other' | 'unknown';
        /**
         * API URL to access this message via the API.
         */
        apiUrl: string;
        /**
         * The ID of the user who sent the message.
         */
        authorId: string | null;
        /**
         * The ID of the parent message.
         */
        parentId?: string | null;
        attachments?: Array<{
            /**
             * The URL where the attachment file can be accessed.
             */
            url: string;
            /**
             * The original filename of the attachment.
             */
            name?: string;
            /**
             * The MIME type of the attachment file (e.g., image/png, application/pdf).
             */
            contentType?: string;
            /**
             * The size of the attachment file in bytes.
             */
            size: number;
            /**
             * The base64-encoded content of the attachment file, if available.
             */
            content?: string;
            /**
             * Optional v0-specific attachment type for enhanced processing.
             */
            type?: 'screenshot' | 'figma' | 'zip';
        }>;
    }>;
    /**
     * Pagination metadata for navigating through multiple pages of results.
     */
    pagination: {
        /**
         * Indicates if there are more results available beyond this page.
         */
        hasMore: boolean;
        /**
         * Cursor for fetching the next page of results.
         */
        nextCursor?: string;
        /**
         * API URL for retrieving the next page of results.
         */
        nextUrl?: string;
    };
};

/**
 * User preference for notification delivery methods.
 */
export type NotificationPreferenceSchema = {
    /**
     * Whether the user wants to receive live activities.
     */
    liveActivity: boolean;
    /**
     * Whether the user wants to receive push notifications.
     */
    pushNotifications: boolean;
};

/**
 * Detailed information about a marketplace or store product.
 */
export type ProductDetailSchema = {
    /**
     * The object type.
     */
    object: 'product';
    /**
     * The unique ID of the product.
     */
    id: string;
    /**
     * The URL-friendly slug of the product.
     */
    slug: string;
    /**
     * The name of the product.
     */
    name: string;
    /**
     * A short description of the product.
     */
    description: string;
    /**
     * URL to the product icon.
     */
    iconUrl: string;
    /**
     * Background color for the product icon.
     */
    iconBackgroundColor?: string;
};

/**
 * List of available marketplace and store products.
 */
export type ProductListSchema = {
    /**
     * Fixed value identifying this as a list response.
     */
    object: 'list';
    /**
     * Array of product summaries.
     */
    data: Array<{
        /**
         * The object type.
         */
        object: 'product';
        /**
         * The unique ID of the product.
         */
        id: string;
        /**
         * The URL-friendly slug of the product.
         */
        slug: string;
        /**
         * The name of the product.
         */
        name: string;
        /**
         * A short description of the product.
         */
        description: string;
        /**
         * URL to the product icon.
         */
        iconUrl: string;
    }>;
};

/**
 * Summary information about a marketplace or store product.
 */
export type ProductSummarySchema = {
    /**
     * The object type.
     */
    object: 'product';
    /**
     * The unique ID of the product.
     */
    id: string;
    /**
     * The URL-friendly slug of the product.
     */
    slug: string;
    /**
     * The name of the product.
     */
    name: string;
    /**
     * A short description of the product.
     */
    description: string;
    /**
     * URL to the product icon.
     */
    iconUrl: string;
};

/**
 * Full representation of a project, including its associated chats.
 */
export type ProjectDetail = {
    /**
     * A unique identifier for the project.
     */
    id: string;
    /**
     * Fixed value identifying this object as a project.
     */
    object: 'project';
    /**
     * The name of the project as defined by the user.
     */
    name: string;
    /**
     * The privacy setting for the project - either private or team.
     */
    privacy: 'private' | 'team';
    /**
     * Optional ID of the linked Vercel project, if connected.
     */
    vercelProjectId?: string;
    /**
     * The ISO timestamp representing when the project was created.
     */
    createdAt: string;
    /**
     * The ISO timestamp of the most recent update, if available.
     */
    updatedAt?: string;
    /**
     * The API endpoint URL for accessing this project programmatically.
     */
    apiUrl: string;
    /**
     * The web URL where the project can be viewed or managed.
     */
    webUrl: string;
    /**
     * The description of the project.
     */
    description?: string;
    /**
     * The instructions for the project.
     */
    instructions?: string;
    /**
     * List of all chats that are associated with this project.
     */
    chats: Array<{
        /**
         * A unique identifier for the chat.
         */
        id: string;
        /**
         * Fixed value identifying this object as a chat.
         */
        object: 'chat';
        /**
         * Indicates whether the chat can be shared via public link.
         */
        shareable: boolean;
        /**
         * Defines the visibility of the chat—private, team-only, or public.
         */
        privacy: 'public' | 'private' | 'team' | 'team-edit' | 'unlisted';
        /**
         * An optional name assigned to the chat by the user.
         */
        name?: string;
        /**
         * Deprecated title field preserved for backward compatibility.
         * @deprecated
         */
        title?: string;
        /**
         * The ISO timestamp representing when the chat was created.
         */
        createdAt: string;
        /**
         * The ISO timestamp of the last update to the chat.
         */
        updatedAt?: string;
        /**
         * Indicates whether the chat is marked as a favorite.
         */
        favorite: boolean;
        /**
         * The ID of the user who created the chat.
         */
        authorId: string;
        /**
         * Optional ID of the v0 project associated with this chat.
         */
        projectId?: string;
        /**
         * Web URL to view this chat in the browser.
         */
        webUrl: string;
        /**
         * API URL to access this chat via the API.
         */
        apiUrl: string;
        /**
         * The most recent generated version of the chat, if available.
         */
        latestVersion?: {
            /**
             * A unique identifier for the version.
             */
            id: string;
            /**
             * Fixed value identifying this object as a version.
             */
            object: 'version';
            /**
             * The current status of the version generation process.
             */
            status: 'pending' | 'completed' | 'failed';
            /**
             * Optional URL for previewing the generated output.
             */
            demoUrl?: string;
            /**
             * The date and time when the version was created, in ISO 8601 format.
             */
            createdAt: string;
            /**
             * The date and time when the version was last updated, in ISO 8601 format.
             */
            updatedAt?: string;
        };
    }>;
};

/**
 * Summary of a project, including metadata, timestamps, and optional Vercel linkage.
 */
export type ProjectSummary = {
    /**
     * A unique identifier for the project.
     */
    id: string;
    /**
     * Fixed value identifying this object as a project.
     */
    object: 'project';
    /**
     * The name of the project as defined by the user.
     */
    name: string;
    /**
     * The privacy setting for the project - either private or team.
     */
    privacy: 'private' | 'team';
    /**
     * Optional ID of the linked Vercel project, if connected.
     */
    vercelProjectId?: string;
    /**
     * The ISO timestamp representing when the project was created.
     */
    createdAt: string;
    /**
     * The ISO timestamp of the most recent update, if available.
     */
    updatedAt?: string;
    /**
     * The API endpoint URL for accessing this project programmatically.
     */
    apiUrl: string;
    /**
     * The web URL where the project can be viewed or managed.
     */
    webUrl: string;
};

/**
 * Basic information about a workspace or identity context for projects and chats.
 */
export type ScopeSummary = {
    /**
     * A unique identifier for the scope (e.g., user or team workspace).
     */
    id: string;
    /**
     * Fixed value identifying this object as a scope.
     */
    object: 'scope';
    /**
     * An optional human-readable name for the scope.
     */
    name?: string;
};

/**
 * Generic result returned from a search query, representing either a chat or a project.
 */
export type SearchResultItem = {
    /**
     * The unique ID of the item returned in the search result.
     */
    id: string;
    /**
     * Type of item returned, either 'chat' or 'project'.
     */
    object: 'chat' | 'project';
    /**
     * The display name of the item.
     */
    name: string;
    /**
     * The ISO timestamp representing when the item was created.
     */
    createdAt: string;
    /**
     * The ISO timestamp of the last update to the item.
     */
    updatedAt?: string;
    /**
     * API endpoint for accessing the item programmatically.
     */
    apiUrl: string;
    /**
     * Web URL for viewing the item in the interface.
     */
    webUrl: string;
};

/**
 * Details of the authenticated user, including profile and contact information.
 */
export type UserDetail = {
    /**
     * A unique identifier for the user.
     */
    id: string;
    /**
     * Fixed value identifying this object as a user.
     */
    object: 'user';
    /**
     * Optional full name of the user.
     */
    name?: string;
    /**
     * The user’s email address.
     */
    email: string;
    /**
     * URL to the user’s avatar image.
     */
    avatar: string;
};

/**
 * Response schema for updating user preferences.
 */
export type UserPreferencesPostResponseSchema = {
    /**
     * Object type identifier.
     */
    object: 'user_preferences';
    /**
     * The updated preferences if successful, or null if failed.
     */
    preferences: {
        /**
         * The user's preferred method for receiving notifications.
         */
        notifications: {
            /**
             * Whether the user wants to receive live activities.
             */
            liveActivity: boolean;
            /**
             * Whether the user wants to receive push notifications.
             */
            pushNotifications: boolean;
        };
    } | null;
};

/**
 * Response schema for retrieving user preferences.
 */
export type UserPreferencesResponseSchema = {
    /**
     * Object type identifier.
     */
    object: 'user_preferences';
    /**
     * The user's current preferences, or null if errored.
     */
    preferences: {
        /**
         * The user's preferred method for receiving notifications.
         */
        notifications: {
            /**
             * Whether the user wants to receive live activities.
             */
            liveActivity: boolean;
            /**
             * Whether the user wants to receive push notifications.
             */
            pushNotifications: boolean;
        };
    } | null;
};

/**
 * User preferences configuration including notification settings.
 */
export type UserPreferencesSchema = {
    /**
     * The user's preferred method for receiving notifications.
     */
    notifications: {
        /**
         * Whether the user wants to receive live activities.
         */
        liveActivity: boolean;
        /**
         * Whether the user wants to receive push notifications.
         */
        pushNotifications: boolean;
    };
};

/**
 * Basic metadata about a Vercel project connected to a v0 project.
 */
export type VercelProjectDetail = {
    /**
     * A unique identifier for the linked Vercel project.
     */
    id: string;
    /**
     * Fixed value identifying this object as a Vercel project.
     */
    object: 'vercel_project';
    /**
     * The name of the Vercel project.
     */
    name: string;
};

/**
 * Basic metadata about a Vercel project connected to a v0 project.
 */
export type VercelProjectSummary = {
    /**
     * A unique identifier for the linked Vercel project.
     */
    id: string;
    /**
     * Fixed value identifying this object as a Vercel project.
     */
    object: 'vercel_project';
    /**
     * The name of the Vercel project.
     */
    name: string;
};

/**
 * Detailed version data including file contents.
 */
export type VersionDetail = {
    /**
     * A unique identifier for the version.
     */
    id: string;
    /**
     * Fixed value identifying this object as a version.
     */
    object: 'version';
    /**
     * The current status of the version generation process.
     */
    status: 'pending' | 'completed' | 'failed';
    /**
     * Optional URL for previewing the generated output.
     */
    demoUrl?: string;
    /**
     * The date and time when the version was created, in ISO 8601 format.
     */
    createdAt: string;
    /**
     * The date and time when the version was last updated, in ISO 8601 format.
     */
    updatedAt?: string;
    /**
     * A list of files that were generated or included in this version.
     */
    files: Array<{
        /**
         * Fixed value identifying this object as a file.
         */
        object: 'file';
        /**
         * The name of the file, including its extension.
         */
        name: string;
        /**
         * The full contents of the file as a raw string.
         */
        content: string;
        /**
         * Whether the file is locked to prevent AI from overwriting it during new version generation.
         */
        locked: boolean;
    }>;
    /**
     * URL to retrieve a screenshot of this version.
     */
    screenshotUrl?: string;
};

/**
 * Summary of a generated version of a chat, including its status and optional demo link.
 */
export type VersionSummary = {
    /**
     * A unique identifier for the version.
     */
    id: string;
    /**
     * Fixed value identifying this object as a version.
     */
    object: 'version';
    /**
     * The current status of the version generation process.
     */
    status: 'pending' | 'completed' | 'failed';
    /**
     * Optional URL for previewing the generated output.
     */
    demoUrl?: string;
    /**
     * The date and time when the version was created, in ISO 8601 format.
     */
    createdAt: string;
    /**
     * The date and time when the version was last updated, in ISO 8601 format.
     */
    updatedAt?: string;
};

/**
 * List response containing multiple version summaries with cursor-based pagination.
 */
export type VersionSummaryList = {
    /**
     * Fixed value identifying this as a list response.
     */
    object: 'list';
    /**
     * Array of version summaries in this page of results.
     */
    data: Array<{
        /**
         * A unique identifier for the version.
         */
        id: string;
        /**
         * Fixed value identifying this object as a version.
         */
        object: 'version';
        /**
         * The current status of the version generation process.
         */
        status: 'pending' | 'completed' | 'failed';
        /**
         * Optional URL for previewing the generated output.
         */
        demoUrl?: string;
        /**
         * The date and time when the version was created, in ISO 8601 format.
         */
        createdAt: string;
        /**
         * The date and time when the version was last updated, in ISO 8601 format.
         */
        updatedAt?: string;
    }>;
    /**
     * Pagination metadata for navigating through multiple pages of results.
     */
    pagination: {
        /**
         * Indicates if there are more results available beyond this page.
         */
        hasMore: boolean;
        /**
         * Cursor for fetching the next page of results.
         */
        nextCursor?: string;
        /**
         * API URL for retrieving the next page of results.
         */
        nextUrl?: string;
    };
};

export type UnauthorizedError = {
    error: {
        message: string;
        type: 'unauthorized_error';
    };
};

export type ForbiddenError = {
    error: {
        message: string;
        type: 'forbidden_error';
    };
};

export type NotFoundError = {
    error: {
        message: string;
        type: 'not_found_error';
    };
};

export type ConflictError = {
    error: {
        message: string;
        type: 'conflict_error';
    };
};

export type PayloadTooLargeError = {
    error: {
        message: string;
        type: 'payload_too_large_error';
    };
};

export type UnprocessableEntityError = {
    error: {
        message: string;
        type: 'unprocessable_entity_error';
    };
};

export type TooManyRequestsError = {
    error: {
        message: string;
        type: 'too_many_requests_error';
    };
};

export type InternalServerError = {
    error: {
        message: string;
        type: 'internal_server_error';
    };
};

export type ChatsFindData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Specifies the maximum number of chat records to return in a single response. Useful for paginating results when there are many chats.
         */
        limit?: number;
        /**
         * Determines the starting point for pagination. Used in conjunction with limit to retrieve a specific page of chat results.
         */
        offset?: number;
        /**
         * Filters chats by their "favorite" status. Accepts `"true"` or `"false"` (as strings, not booleans).
         *
         * - `"true"`: returns only chats marked as favorites.
         * - `"false"`: returns only non-favorite chats.
         */
        isFavorite?: 'true' | 'false';
    };
    url: '/chats';
};

export type ChatsFindErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type ChatsFindError = ChatsFindErrors[keyof ChatsFindErrors];

export type ChatsFindResponses = {
    /**
     * Success
     */
    200: {
        object: 'list';
        data: Array<ChatSummary>;
    };
};

export type ChatsFindResponse = ChatsFindResponses[keyof ChatsFindResponses];

export type ChatsCreateData = {
    body: {
        /**
         * Creates a new chat using a user message, optional system context, and model configuration. Useful for prompting the model within the scope of a specific project.
         */
        message: string;
        /**
         * A list of files or assets to be included in the conversation context. Useful when the chat or task requires referencing documents, images, or other resources.
         */
        attachments?: Array<{
            url: string;
        }>;
        /**
         * Provides system-level context or background for the chat. This is typically used to specify frameworks, tools, or development environments relevant to the task.
         */
        system?: string;
        /**
         * Determines the privacy setting of the chat. This can control whether the chat is visible only to the user, to team members, or is public.
         */
        chatPrivacy?: 'public' | 'private' | 'team-edit' | 'team' | 'unlisted';
        /**
         * Associates the chat with a specific project in your workspace. Helps organize and group related chats under a common project context.
         */
        projectId?: string;
        /**
         * Settings that control how the model behaves in the chat.
         */
        modelConfiguration?: {
            /**
             * Deprecated Model ID field preserved for backward compatibility.
             * @deprecated
             */
            modelId?: 'v0-1.5-sm' | 'v0-1.5-md' | 'v0-1.5-lg' | 'v0-gpt-5';
            /**
             * Enables image generations to generate up to 5 images per version.
             */
            imageGenerations?: boolean;
            /**
             * Enables thinking to generate a response in multiple steps.
             */
            thinking?: boolean;
        };
        /**
         * Controls how the response is delivered.
         *
         * - `"sync"`: The response is returned immediately with the HTTP request.
         * - `"async"`: Returns a message placeholder immediately; use getById to poll for completion status and final output.
         * - `"experimental_stream"`: Returns content parts as Server-Sent Events for real-time streaming.
         */
        responseMode?: 'sync' | 'async' | 'experimental_stream';
        /**
         * The ID of a design system to apply to this chat. Design systems provide consistent styling and components for generated UI.
         */
        designSystemId?: string | null;
    };
    path?: never;
    query?: never;
    url: '/chats';
};

export type ChatsCreateErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type ChatsCreateError = ChatsCreateErrors[keyof ChatsCreateErrors];

export type ChatsCreateResponses = {
    /**
     * Success
     */
    200: ChatDetail;
};

export type ChatsCreateResponse = ChatsCreateResponses[keyof ChatsCreateResponses];

export type ChatsInitData = {
    body: {
        /**
         * A user-defined name for the chat. Helps identify or describe the purpose of the chat session in the UI or API responses.
         */
        name?: string;
        /**
         * Controls the visibility of the chat. Defines whether the chat is private, shared with a team, or publicly accessible.
         */
        chatPrivacy?: 'public' | 'private' | 'team-edit' | 'team' | 'unlisted';
        /**
         * Associates the chat with a specific project. Useful for organizing and grouping chats in a workspace.
         */
        projectId?: string;
    } & ({
        /**
         * Specifies the initialization method. For this endpoint, it defines the source of content being used to initialize the chat.
         */
        type: 'files';
        /**
         * An array of inline file objects used to initialize the chat. Each object must contain a file `name` and its `content`.
         */
        files: Array<{
            name: string;
            url: string;
            /**
             * Whether to lock this file to prevent AI from overwriting it during generation
             */
            locked?: boolean;
        } | {
            name: string;
            content: string;
            /**
             * Whether to lock this file to prevent AI from overwriting it during generation
             */
            locked?: boolean;
        }>;
    } | {
        /**
         * Specifies the initialization method. For this endpoint, it defines the source of content being used to initialize the chat.
         */
        type: 'repo';
        /**
         * Specifies a repository source for initialization. Supports both public and private GitHub repositories. For private repositories, ensure your GitHub account is connected through Vercel.
         */
        repo: {
            url: string;
            branch?: string;
        };
        /**
         * Whether to lock all files in the repository to prevent AI from overwriting them during generation
         */
        lockAllFiles?: boolean;
    } | {
        /**
         * Specifies the initialization method. For this endpoint, it defines the source of content being used to initialize the chat.
         */
        type: 'registry';
        /**
         * Allows initialization from a predefined component or code registry. Includes the registry source and identifier for the desired component/module.
         */
        registry: {
            url: string;
        };
        /**
         * Whether to lock all files from the registry to prevent AI from overwriting them during generation
         */
        lockAllFiles?: boolean;
    } | {
        /**
         * Specifies the initialization method. For this endpoint, it defines the source of content being used to initialize the chat.
         */
        type: 'zip';
        /**
         * Provides a zipped bundle of files as the input source. Typically includes a base64-encoded archive or a remote URL reference.
         */
        zip: {
            url: string;
        };
        /**
         * Whether to lock all files from the zip archive to prevent AI from overwriting them during generation
         */
        lockAllFiles?: boolean;
    } | {
        /**
         * Specifies the initialization method. For this endpoint, it defines the source of content being used to initialize the chat.
         */
        type: 'template';
        /**
         * The ID of the template to initialize the chat from. This should be a valid template ID from the v0 template system.
         */
        templateId: string;
    });
    path?: never;
    query?: never;
    url: '/chats/init';
};

export type ChatsInitErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type ChatsInitError = ChatsInitErrors[keyof ChatsInitErrors];

export type ChatsInitResponses = {
    /**
     * Success
     */
    200: ChatDetail;
};

export type ChatsInitResponse = ChatsInitResponses[keyof ChatsInitResponses];

export type ChatsDeleteData = {
    body?: never;
    path: {
        /**
         * The unique identifier of the chat to delete. This must be passed as a path parameter in the URL.
         */
        chatId: string;
    };
    query?: never;
    url: '/chats/{chatId}';
};

export type ChatsDeleteErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type ChatsDeleteError = ChatsDeleteErrors[keyof ChatsDeleteErrors];

export type ChatsDeleteResponses = {
    /**
     * Success
     */
    200: {
        id: string;
        object: 'chat';
        deleted: true;
    };
};

export type ChatsDeleteResponse = ChatsDeleteResponses[keyof ChatsDeleteResponses];

export type ChatsGetByIdData = {
    body?: never;
    path: {
        /**
         * The unique identifier of the chat to retrieve. Must be provided as a path parameter.
         */
        chatId: string;
    };
    query?: never;
    url: '/chats/{chatId}';
};

export type ChatsGetByIdErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type ChatsGetByIdError = ChatsGetByIdErrors[keyof ChatsGetByIdErrors];

export type ChatsGetByIdResponses = {
    /**
     * Success
     */
    200: ChatDetail;
};

export type ChatsGetByIdResponse = ChatsGetByIdResponses[keyof ChatsGetByIdResponses];

export type ChatsUpdateData = {
    body: {
        /**
         * A new name to assign to the chat. Helps with identification and organization.
         */
        name?: string;
        /**
         * Sets the privacy level of the chat.
         */
        privacy?: 'public' | 'private' | 'team' | 'team-edit' | 'unlisted';
    };
    path: {
        /**
         * The unique identifier of the chat to update. Provided as a path parameter.
         */
        chatId: string;
    };
    query?: never;
    url: '/chats/{chatId}';
};

export type ChatsUpdateErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type ChatsUpdateError = ChatsUpdateErrors[keyof ChatsUpdateErrors];

export type ChatsUpdateResponses = {
    /**
     * Success
     */
    200: ChatDetail;
};

export type ChatsUpdateResponse = ChatsUpdateResponses[keyof ChatsUpdateResponses];

export type ChatsFavoriteData = {
    body: {
        /**
         * Specifies whether the chat should be marked as a favorite.
         *
         * - `"true"`: mark as favorite
         * - `"false"`: remove from favorites
         */
        isFavorite: boolean;
    };
    path: {
        /**
         * The unique identifier of the chat to update. Provided as a path parameter.
         */
        chatId: string;
    };
    query?: never;
    url: '/chats/{chatId}/favorite';
};

export type ChatsFavoriteErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type ChatsFavoriteError = ChatsFavoriteErrors[keyof ChatsFavoriteErrors];

export type ChatsFavoriteResponses = {
    /**
     * Success
     */
    200: {
        id: string;
        object: 'chat';
        favorited: boolean;
    };
};

export type ChatsFavoriteResponse = ChatsFavoriteResponses[keyof ChatsFavoriteResponses];

export type ChatsForkData = {
    body: {
        /**
         * The identifier of the specific chat version to fork from. If omitted, the latest version will be used.
         */
        versionId?: string;
        /**
         * Determines the privacy setting of the forked chat. This can control whether the chat is visible only to the user, to team members, or is public.
         */
        privacy?: 'public' | 'private' | 'team' | 'team-edit' | 'unlisted';
    };
    path: {
        /**
         * The unique identifier of the chat to fork. Provided as a path parameter.
         */
        chatId: string;
    };
    query?: never;
    url: '/chats/{chatId}/fork';
};

export type ChatsForkErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type ChatsForkError = ChatsForkErrors[keyof ChatsForkErrors];

export type ChatsForkResponses = {
    /**
     * Success
     */
    200: ChatDetail;
};

export type ChatsForkResponse = ChatsForkResponses[keyof ChatsForkResponses];

export type ProjectsGetByChatIdData = {
    body?: never;
    path: {
        /**
         * The ID of the chat to retrieve the associated project for.
         */
        chatId: string;
    };
    query?: never;
    url: '/chats/{chatId}/project';
};

export type ProjectsGetByChatIdErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type ProjectsGetByChatIdError = ProjectsGetByChatIdErrors[keyof ProjectsGetByChatIdErrors];

export type ProjectsGetByChatIdResponses = {
    /**
     * Success
     */
    200: ProjectDetail;
};

export type ProjectsGetByChatIdResponse = ProjectsGetByChatIdResponses[keyof ProjectsGetByChatIdResponses];

export type ChatsFindMessagesData = {
    body?: never;
    path: {
        /**
         * The unique identifier of the chat to retrieve messages for. Provided as a path parameter.
         */
        chatId: string;
    };
    query?: {
        /**
         * Specifies the maximum number of message records to return in a single response. Useful for paginating results when there are many messages.
         */
        limit?: number;
        /**
         * Base64 encoded cursor containing pagination data
         */
        cursor?: string;
    };
    url: '/chats/{chatId}/messages';
};

export type ChatsFindMessagesErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type ChatsFindMessagesError = ChatsFindMessagesErrors[keyof ChatsFindMessagesErrors];

export type ChatsFindMessagesResponses = {
    /**
     * Success
     */
    200: {
        object: 'list';
        data: Array<MessageSummary>;
        pagination: {
            hasMore: boolean;
            nextCursor?: string;
            nextUrl?: string;
        };
    };
};

export type ChatsFindMessagesResponse = ChatsFindMessagesResponses[keyof ChatsFindMessagesResponses];

export type ChatsSendMessageData = {
    body: {
        /**
         * The prompt or instruction to send to the model as part of the chat.
         */
        message: string;
        /**
         * A list of files or assets to include with the message.
         */
        attachments?: Array<{
            url: string;
        }>;
        /**
         * Overrides for the model behavior.
         */
        modelConfiguration?: {
            /**
             * Deprecated Model ID field preserved for backward compatibility.
             * @deprecated
             */
            modelId?: 'v0-1.5-sm' | 'v0-1.5-md' | 'v0-1.5-lg' | 'v0-gpt-5';
            /**
             * Enables image generations to generate up to 5 images per version.
             */
            imageGenerations?: boolean;
            /**
             * Enables thinking to generate a response in multiple steps.
             */
            thinking?: boolean;
        };
        /**
         * Controls how the response is delivered.
         *
         * - `"sync"`: The response is returned immediately with the HTTP request.
         * - `"async"`: Returns a message placeholder immediately; use getById to poll for completion status and final output.
         * - `"experimental_stream"`: Returns content parts as Server-Sent Events for real-time streaming.
         */
        responseMode?: 'sync' | 'async' | 'experimental_stream';
    };
    path: {
        /**
         * The unique identifier of the chat to send the message to. Provided as a path parameter.
         */
        chatId: string;
    };
    query?: never;
    url: '/chats/{chatId}/messages';
};

export type ChatsSendMessageErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type ChatsSendMessageError = ChatsSendMessageErrors[keyof ChatsSendMessageErrors];

export type ChatsSendMessageResponses = {
    /**
     * Success
     */
    200: ChatDetail;
};

export type ChatsSendMessageResponse = ChatsSendMessageResponses[keyof ChatsSendMessageResponses];

export type ChatsGetMessageData = {
    body?: never;
    path: {
        /**
         * The unique identifier of the chat containing the message. Provided as a path parameter.
         */
        chatId: string;
        /**
         * The unique identifier of the message to retrieve. Provided as a path parameter.
         */
        messageId: string;
    };
    query?: never;
    url: '/chats/{chatId}/messages/{messageId}';
};

export type ChatsGetMessageErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type ChatsGetMessageError = ChatsGetMessageErrors[keyof ChatsGetMessageErrors];

export type ChatsGetMessageResponses = {
    /**
     * Success
     */
    200: MessageDetail;
};

export type ChatsGetMessageResponse = ChatsGetMessageResponses[keyof ChatsGetMessageResponses];

export type ChatsFindVersionsData = {
    body?: never;
    path: {
        /**
         * The unique identifier of the chat to retrieve versions for. Provided as a path parameter.
         */
        chatId: string;
    };
    query?: {
        /**
         * Specifies the maximum number of version records to return in a single response. Useful for paginating results when there are many versions.
         */
        limit?: number;
        /**
         * Base64 encoded cursor containing pagination data
         */
        cursor?: string;
    };
    url: '/chats/{chatId}/versions';
};

export type ChatsFindVersionsErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type ChatsFindVersionsError = ChatsFindVersionsErrors[keyof ChatsFindVersionsErrors];

export type ChatsFindVersionsResponses = {
    /**
     * Success
     */
    200: {
        object: 'list';
        data: Array<VersionSummary>;
        pagination: {
            hasMore: boolean;
            nextCursor?: string;
            nextUrl?: string;
        };
    };
};

export type ChatsFindVersionsResponse = ChatsFindVersionsResponses[keyof ChatsFindVersionsResponses];

export type ChatsGetVersionData = {
    body?: never;
    path: {
        /**
         * The unique identifier of the chat containing the version. Provided as a path parameter.
         */
        chatId: string;
        /**
         * The unique identifier of the version to retrieve. Provided as a path parameter.
         */
        versionId: string;
    };
    query?: {
        /**
         * When true, includes all default files (package.json, configuration files, etc.) that would be part of a ZIP download. When false or omitted, returns only the generated source files.
         */
        includeDefaultFiles?: 'true' | 'false';
    };
    url: '/chats/{chatId}/versions/{versionId}';
};

export type ChatsGetVersionErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type ChatsGetVersionError = ChatsGetVersionErrors[keyof ChatsGetVersionErrors];

export type ChatsGetVersionResponses = {
    /**
     * Success
     */
    200: VersionDetail;
};

export type ChatsGetVersionResponse = ChatsGetVersionResponses[keyof ChatsGetVersionResponses];

export type ChatsUpdateVersionData = {
    body: {
        /**
         * Array of files to update with their new content
         */
        files: Array<{
            /**
             * The full file path including extension (e.g., "components/test.tsx")
             */
            name: string;
            /**
             * The new content for the file
             */
            content: string;
            /**
             * Whether to lock or unlock the file to prevent AI from overwriting it during generation
             */
            locked?: boolean;
        }>;
    };
    path: {
        /**
         * The unique identifier of the chat containing the version to update. Provided as a path parameter.
         */
        chatId: string;
        /**
         * The unique identifier of the version (block) to update. Provided as a path parameter.
         */
        versionId: string;
    };
    query?: never;
    url: '/chats/{chatId}/versions/{versionId}';
};

export type ChatsUpdateVersionErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type ChatsUpdateVersionError = ChatsUpdateVersionErrors[keyof ChatsUpdateVersionErrors];

export type ChatsUpdateVersionResponses = {
    /**
     * Success
     */
    200: VersionDetail;
};

export type ChatsUpdateVersionResponse = ChatsUpdateVersionResponses[keyof ChatsUpdateVersionResponses];

export type ChatsDownloadVersionData = {
    body?: never;
    path: {
        /**
         * The unique identifier of the chat containing the version. Provided as a path parameter.
         */
        chatId: string;
        /**
         * The unique identifier of the version to download. Provided as a path parameter.
         */
        versionId: string;
    };
    query?: {
        /**
         * The archive format for the download. Choose "zip" for broad compatibility or "tarball" for Unix/Linux systems.
         */
        format?: 'zip' | 'tarball';
        /**
         * When true, includes all default files (package.json, configuration files, etc.) that would be part of a complete deployment. When false or omitted, returns only the generated source files.
         */
        includeDefaultFiles?: 'true' | 'false';
    };
    url: '/chats/{chatId}/versions/{versionId}/download';
};

export type ChatsDownloadVersionErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type ChatsDownloadVersionError = ChatsDownloadVersionErrors[keyof ChatsDownloadVersionErrors];

export type ChatsDownloadVersionResponses = {
    /**
     * ZIP archive containing the version files
     */
    200: Blob | File;
};

export type ChatsDownloadVersionResponse = ChatsDownloadVersionResponses[keyof ChatsDownloadVersionResponses];

export type ChatsResumeData = {
    body?: never;
    path: {
        /**
         * The unique identifier of the chat containing the message to resume. Provided as a path parameter.
         */
        chatId: string;
        /**
         * The identifier of the specific message to resume. Provided as a path parameter.
         */
        messageId: string;
    };
    query?: never;
    url: '/chats/{chatId}/messages/{messageId}/resume';
};

export type ChatsResumeErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type ChatsResumeError = ChatsResumeErrors[keyof ChatsResumeErrors];

export type ChatsResumeResponses = {
    /**
     * Success
     */
    200: MessageDetail;
};

export type ChatsResumeResponse = ChatsResumeResponses[keyof ChatsResumeResponses];

export type DeploymentsFindData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The ID of the project to find deployments for
         */
        projectId: string;
        /**
         * The ID of the chat to find deployments for
         */
        chatId: string;
        /**
         * The ID of the version to find deployments for
         */
        versionId: string;
    };
    url: '/deployments';
};

export type DeploymentsFindErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type DeploymentsFindError = DeploymentsFindErrors[keyof DeploymentsFindErrors];

export type DeploymentsFindResponses = {
    /**
     * Success
     */
    200: {
        object: 'list';
        data: Array<DeploymentDetail>;
    };
};

export type DeploymentsFindResponse = DeploymentsFindResponses[keyof DeploymentsFindResponses];

export type DeploymentsCreateData = {
    body: {
        projectId: string;
        chatId: string;
        versionId: string;
    };
    path?: never;
    query?: never;
    url: '/deployments';
};

export type DeploymentsCreateErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type DeploymentsCreateError = DeploymentsCreateErrors[keyof DeploymentsCreateErrors];

export type DeploymentsCreateResponses = {
    /**
     * Success
     */
    200: DeploymentDetail;
};

export type DeploymentsCreateResponse = DeploymentsCreateResponses[keyof DeploymentsCreateResponses];

export type DeploymentsDeleteData = {
    body?: never;
    path: {
        /**
         * Path parameter "deploymentId"
         */
        deploymentId: string;
    };
    query?: never;
    url: '/deployments/{deploymentId}';
};

export type DeploymentsDeleteErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type DeploymentsDeleteError = DeploymentsDeleteErrors[keyof DeploymentsDeleteErrors];

export type DeploymentsDeleteResponses = {
    /**
     * Success
     */
    200: {
        id: string;
        object: 'deployment';
        deleted: true;
    };
};

export type DeploymentsDeleteResponse = DeploymentsDeleteResponses[keyof DeploymentsDeleteResponses];

export type DeploymentsGetByIdData = {
    body?: never;
    path: {
        /**
         * Path parameter "deploymentId"
         */
        deploymentId: string;
    };
    query?: never;
    url: '/deployments/{deploymentId}';
};

export type DeploymentsGetByIdErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type DeploymentsGetByIdError = DeploymentsGetByIdErrors[keyof DeploymentsGetByIdErrors];

export type DeploymentsGetByIdResponses = {
    /**
     * Success
     */
    200: DeploymentDetail;
};

export type DeploymentsGetByIdResponse = DeploymentsGetByIdResponses[keyof DeploymentsGetByIdResponses];

export type DeploymentsFindLogsData = {
    body?: never;
    path: {
        /**
         * The unique identifier of the deployment to retrieve logs for. Provided as a path parameter.
         */
        deploymentId: string;
    };
    query?: {
        /**
         * A UNIX timestamp (in seconds) used to filter logs. Returns only log entries generated after the specified time.
         */
        since?: number;
    };
    url: '/deployments/{deploymentId}/logs';
};

export type DeploymentsFindLogsErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type DeploymentsFindLogsError = DeploymentsFindLogsErrors[keyof DeploymentsFindLogsErrors];

export type DeploymentsFindLogsResponses = {
    /**
     * Success
     */
    200: {
        /**
         * Array of log entries.
         */
        logs: Array<{
            /**
             * Log creation timestamp.
             */
            createdAt: string;
            /**
             * Deployment ID.
             */
            deploymentId: string;
            /**
             * Log entry ID.
             */
            id: string;
            /**
             * Log message content.
             */
            text: string;
            /**
             * Output stream type.
             */
            type: 'stdout' | 'stderr';
            /**
             * Log severity level.
             */
            level?: 'error' | 'warning' | 'info';
            /**
             * Object type identifier.
             */
            object: 'deployment_log';
        }>;
        /**
         * Timestamp for pagination.
         */
        nextSince?: number;
        /**
         * Object type identifier.
         */
        object: 'list';
    };
};

export type DeploymentsFindLogsResponse = DeploymentsFindLogsResponses[keyof DeploymentsFindLogsResponses];

export type DeploymentsFindErrorsData = {
    body?: never;
    path: {
        /**
         * The unique identifier of the deployment to inspect for errors. Provided as a path parameter.
         */
        deploymentId: string;
    };
    query?: never;
    url: '/deployments/{deploymentId}/errors';
};

export type DeploymentsFindErrorsErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type DeploymentsFindErrorsError = DeploymentsFindErrorsErrors[keyof DeploymentsFindErrorsErrors];

export type DeploymentsFindErrorsResponses = {
    /**
     * Success
     */
    200: {
        error?: string;
        fullErrorText?: string;
        errorType?: string;
        formattedError?: string;
    };
};

export type DeploymentsFindErrorsResponse = DeploymentsFindErrorsResponses[keyof DeploymentsFindErrorsResponses];

export type HooksFindData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/hooks';
};

export type HooksFindErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type HooksFindError = HooksFindErrors[keyof HooksFindErrors];

export type HooksFindResponses = {
    /**
     * Success
     */
    200: {
        object: 'list';
        data: Array<HookSummary>;
    };
};

export type HooksFindResponse = HooksFindResponses[keyof HooksFindResponses];

export type HooksCreateData = {
    body: {
        /**
         * A human-readable name for the hook.
         */
        name: string;
        /**
         * List of event types the hook should subscribe to.
         */
        events: Array<'chat.created' | 'chat.updated' | 'chat.deleted' | 'message.created' | 'message.updated' | 'message.deleted' | 'message.finished'>;
        /**
         * The ID of a chat to scope the hook to.
         */
        chatId?: string;
        /**
         * The target URL to receive the webhook payloads.
         */
        url: string;
    };
    path?: never;
    query?: never;
    url: '/hooks';
};

export type HooksCreateErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type HooksCreateError = HooksCreateErrors[keyof HooksCreateErrors];

export type HooksCreateResponses = {
    /**
     * Success
     */
    200: HookDetail;
};

export type HooksCreateResponse = HooksCreateResponses[keyof HooksCreateResponses];

export type HooksDeleteData = {
    body?: never;
    path: {
        /**
         * The ID of the webhook to delete. Provided as a path parameter.
         */
        hookId: string;
    };
    query?: never;
    url: '/hooks/{hookId}';
};

export type HooksDeleteErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type HooksDeleteError = HooksDeleteErrors[keyof HooksDeleteErrors];

export type HooksDeleteResponses = {
    /**
     * Success
     */
    200: {
        id: string;
        object: 'hook';
        deleted: true;
    };
};

export type HooksDeleteResponse = HooksDeleteResponses[keyof HooksDeleteResponses];

export type HooksGetByIdData = {
    body?: never;
    path: {
        /**
         * The unique identifier of the hook to retrieve.
         */
        hookId: string;
    };
    query?: never;
    url: '/hooks/{hookId}';
};

export type HooksGetByIdErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type HooksGetByIdError = HooksGetByIdErrors[keyof HooksGetByIdErrors];

export type HooksGetByIdResponses = {
    /**
     * Success
     */
    200: HookDetail;
};

export type HooksGetByIdResponse = HooksGetByIdResponses[keyof HooksGetByIdResponses];

export type HooksUpdateData = {
    body: {
        /**
         * A new name for the hook.
         */
        name?: string;
        /**
         * Updated list of event types to subscribe to.
         */
        events?: Array<'chat.created' | 'chat.updated' | 'chat.deleted' | 'message.created' | 'message.updated' | 'message.deleted' | 'message.finished'>;
        /**
         * A new URL to send webhook payloads to.
         */
        url?: string;
    };
    path: {
        /**
         * The ID of the webhook to update. Provided as a path parameter.
         */
        hookId: string;
    };
    query?: never;
    url: '/hooks/{hookId}';
};

export type HooksUpdateErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type HooksUpdateError = HooksUpdateErrors[keyof HooksUpdateErrors];

export type HooksUpdateResponses = {
    /**
     * Success
     */
    200: HookDetail;
};

export type HooksUpdateResponse = HooksUpdateResponses[keyof HooksUpdateResponses];

export type IntegrationsVercelProjectsFindData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/integrations/vercel/projects';
};

export type IntegrationsVercelProjectsFindErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type IntegrationsVercelProjectsFindError = IntegrationsVercelProjectsFindErrors[keyof IntegrationsVercelProjectsFindErrors];

export type IntegrationsVercelProjectsFindResponses = {
    /**
     * Success
     */
    200: {
        object: 'list';
        data: Array<VercelProjectDetail>;
    };
};

export type IntegrationsVercelProjectsFindResponse = IntegrationsVercelProjectsFindResponses[keyof IntegrationsVercelProjectsFindResponses];

export type IntegrationsVercelProjectsCreateData = {
    body: {
        /**
         * The ID of the v0 project to link to the new Vercel project.
         */
        projectId: string;
        /**
         * The name to assign to the new Vercel project.
         */
        name: string;
    };
    path?: never;
    query?: never;
    url: '/integrations/vercel/projects';
};

export type IntegrationsVercelProjectsCreateErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type IntegrationsVercelProjectsCreateError = IntegrationsVercelProjectsCreateErrors[keyof IntegrationsVercelProjectsCreateErrors];

export type IntegrationsVercelProjectsCreateResponses = {
    /**
     * Success
     */
    200: VercelProjectDetail;
};

export type IntegrationsVercelProjectsCreateResponse = IntegrationsVercelProjectsCreateResponses[keyof IntegrationsVercelProjectsCreateResponses];

export type ProjectsFindData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/projects';
};

export type ProjectsFindErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type ProjectsFindError = ProjectsFindErrors[keyof ProjectsFindErrors];

export type ProjectsFindResponses = {
    /**
     * Success
     */
    200: {
        object: 'list';
        data: Array<ProjectSummary>;
    };
};

export type ProjectsFindResponse = ProjectsFindResponses[keyof ProjectsFindResponses];

export type ProjectsCreateData = {
    body: {
        /**
         * The name of the project.
         */
        name: string;
        /**
         * A brief summary of the project’s purpose.
         */
        description?: string;
        /**
         * An icon identifier to visually represent the project.
         */
        icon?: string;
        /**
         * A list of key-value pairs used to define runtime variables for the project.
         */
        environmentVariables?: Array<{
            key: string;
            value: string;
        }>;
        /**
         * Guidance or goals that provide context for the model when working within the project.
         */
        instructions?: string;
        /**
         * The ID of an existing Vercel project to link to. If not provided, a new Vercel project will be created.
         */
        vercelProjectId?: string;
        /**
         * The privacy setting for the project. For user accounts, this is always "private". For team/enterprise accounts, this can be either "private" or "team".
         */
        privacy?: 'private' | 'team';
    };
    path?: never;
    query?: never;
    url: '/projects';
};

export type ProjectsCreateErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type ProjectsCreateError = ProjectsCreateErrors[keyof ProjectsCreateErrors];

export type ProjectsCreateResponses = {
    /**
     * Success
     */
    200: ProjectDetail;
};

export type ProjectsCreateResponse = ProjectsCreateResponses[keyof ProjectsCreateResponses];

export type ProjectsDeleteData = {
    body?: never;
    path: {
        /**
         * The unique identifier of the project to delete. This must be passed as a path parameter in the URL.
         */
        projectId: string;
    };
    query?: never;
    url: '/projects/{projectId}';
};

export type ProjectsDeleteErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type ProjectsDeleteError = ProjectsDeleteErrors[keyof ProjectsDeleteErrors];

export type ProjectsDeleteResponses = {
    /**
     * Success
     */
    200: {
        /**
         * The unique identifier of the deleted project.
         */
        id: string;
        /**
         * Fixed value identifying this object as a project.
         */
        object: 'project';
        /**
         * Confirmation that the project has been deleted.
         */
        deleted: true;
    };
};

export type ProjectsDeleteResponse = ProjectsDeleteResponses[keyof ProjectsDeleteResponses];

export type ProjectsGetByIdData = {
    body?: never;
    path: {
        /**
         * The unique identifier of the project to retrieve.
         */
        projectId: string;
    };
    query?: never;
    url: '/projects/{projectId}';
};

export type ProjectsGetByIdErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type ProjectsGetByIdError = ProjectsGetByIdErrors[keyof ProjectsGetByIdErrors];

export type ProjectsGetByIdResponses = {
    /**
     * Success
     */
    200: ProjectDetail;
};

export type ProjectsGetByIdResponse = ProjectsGetByIdResponses[keyof ProjectsGetByIdResponses];

export type ProjectsUpdateData = {
    body: {
        /**
         * A new name to assign to the project. Helps with identification and organization.
         */
        name?: string;
        /**
         * A new description to assign to the project. Helps with identification and organization.
         */
        description?: string;
        /**
         * Guidance or goals that provide context for the model when working within the project.
         */
        instructions?: string;
        /**
         * The privacy setting for the project. For user accounts, this must be "private". For team/enterprise accounts, this can be either "private" or "team".
         */
        privacy?: 'private' | 'team';
    };
    path: {
        /**
         * The unique identifier of the project to update. Provided as a path parameter.
         */
        projectId: string;
    };
    query?: never;
    url: '/projects/{projectId}';
};

export type ProjectsUpdateErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type ProjectsUpdateError = ProjectsUpdateErrors[keyof ProjectsUpdateErrors];

export type ProjectsUpdateResponses = {
    /**
     * Success
     */
    200: ProjectDetail;
};

export type ProjectsUpdateResponse = ProjectsUpdateResponses[keyof ProjectsUpdateResponses];

export type ProjectsAssignData = {
    body: {
        /**
         * The ID of the chat to assign the project to.
         */
        chatId: string;
    };
    path: {
        /**
         * The ID of the project to assign.
         */
        projectId: string;
    };
    query?: never;
    url: '/projects/{projectId}/assign';
};

export type ProjectsAssignErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type ProjectsAssignError = ProjectsAssignErrors[keyof ProjectsAssignErrors];

export type ProjectsAssignResponses = {
    /**
     * Success
     */
    200: {
        object: 'project';
        id: string;
        assigned: true;
    };
};

export type ProjectsAssignResponse = ProjectsAssignResponses[keyof ProjectsAssignResponses];

export type ProjectsFindEnvVarsData = {
    body?: never;
    path: {
        /**
         * The unique identifier of the project whose environment variables should be retrieved.
         */
        projectId: string;
    };
    query?: {
        /**
         * Whether to return decrypted values. Defaults to false (encrypted).
         */
        decrypted?: 'true' | 'false';
    };
    url: '/projects/{projectId}/env-vars';
};

export type ProjectsFindEnvVarsErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type ProjectsFindEnvVarsError = ProjectsFindEnvVarsErrors[keyof ProjectsFindEnvVarsErrors];

export type ProjectsFindEnvVarsResponses = {
    /**
     * Success
     */
    200: {
        object: 'list';
        data: Array<EnvironmentVariableSummarySchema>;
    };
};

export type ProjectsFindEnvVarsResponse = ProjectsFindEnvVarsResponses[keyof ProjectsFindEnvVarsResponses];

export type ProjectsUpdateEnvVarsData = {
    body: {
        /**
         * An array of environment variables to update with id and value fields.
         */
        environmentVariables: Array<{
            /**
             * The unique identifier of the environment variable to update.
             */
            id: string;
            /**
             * The new value of the environment variable.
             */
            value: string;
        }>;
    };
    path: {
        /**
         * The unique identifier of the project whose environment variables should be updated.
         */
        projectId: string;
    };
    query?: {
        /**
         * Whether to return decrypted values. Defaults to false (encrypted).
         */
        decrypted?: 'true' | 'false';
    };
    url: '/projects/{projectId}/env-vars';
};

export type ProjectsUpdateEnvVarsErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type ProjectsUpdateEnvVarsError = ProjectsUpdateEnvVarsErrors[keyof ProjectsUpdateEnvVarsErrors];

export type ProjectsUpdateEnvVarsResponses = {
    /**
     * Success
     */
    200: {
        object: 'list';
        data: Array<EnvironmentVariableSummarySchema>;
    };
};

export type ProjectsUpdateEnvVarsResponse = ProjectsUpdateEnvVarsResponses[keyof ProjectsUpdateEnvVarsResponses];

export type ProjectsCreateEnvVarsData = {
    body: {
        /**
         * An array of environment variables to create with key and value fields.
         */
        environmentVariables: Array<{
            /**
             * The name of the environment variable.
             */
            key: string;
            /**
             * The value of the environment variable.
             */
            value: string;
        }>;
        /**
         * Whether to overwrite existing environment variables with the same keys. Defaults to false.
         */
        upsert?: boolean;
    };
    path: {
        /**
         * The unique identifier of the project where environment variables should be created.
         */
        projectId: string;
    };
    query?: {
        /**
         * Whether to return decrypted values. Defaults to false (encrypted).
         */
        decrypted?: 'true' | 'false';
    };
    url: '/projects/{projectId}/env-vars';
};

export type ProjectsCreateEnvVarsErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type ProjectsCreateEnvVarsError = ProjectsCreateEnvVarsErrors[keyof ProjectsCreateEnvVarsErrors];

export type ProjectsCreateEnvVarsResponses = {
    /**
     * Success
     */
    200: {
        object: 'list';
        data: Array<EnvironmentVariableSummarySchema>;
    };
};

export type ProjectsCreateEnvVarsResponse = ProjectsCreateEnvVarsResponses[keyof ProjectsCreateEnvVarsResponses];

export type ProjectsDeleteEnvVarsData = {
    body: {
        /**
         * An array of environment variable IDs to delete.
         */
        environmentVariableIds: Array<string>;
    };
    path: {
        /**
         * The unique identifier of the project whose environment variables should be deleted.
         */
        projectId: string;
    };
    query?: never;
    url: '/projects/{projectId}/env-vars/delete';
};

export type ProjectsDeleteEnvVarsErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type ProjectsDeleteEnvVarsError = ProjectsDeleteEnvVarsErrors[keyof ProjectsDeleteEnvVarsErrors];

export type ProjectsDeleteEnvVarsResponses = {
    /**
     * Success
     */
    200: {
        object: 'list';
        data: Array<{
            id: string;
            object: 'environment_variable';
            deleted: true;
        }>;
    };
};

export type ProjectsDeleteEnvVarsResponse = ProjectsDeleteEnvVarsResponses[keyof ProjectsDeleteEnvVarsResponses];

export type ProjectsGetEnvVarData = {
    body?: never;
    path: {
        /**
         * The unique identifier of the project that owns the environment variable.
         */
        projectId: string;
        /**
         * The unique identifier of the environment variable to retrieve.
         */
        environmentVariableId: string;
    };
    query?: {
        /**
         * Whether to return decrypted values. Defaults to false (encrypted).
         */
        decrypted?: 'true' | 'false';
    };
    url: '/projects/{projectId}/env-vars/{environmentVariableId}';
};

export type ProjectsGetEnvVarErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type ProjectsGetEnvVarError = ProjectsGetEnvVarErrors[keyof ProjectsGetEnvVarErrors];

export type ProjectsGetEnvVarResponses = {
    /**
     * Success
     */
    200: {
        object: 'environment_variable';
        data: EnvironmentVariableDetailSchema;
    };
};

export type ProjectsGetEnvVarResponse = ProjectsGetEnvVarResponses[keyof ProjectsGetEnvVarResponses];

export type RateLimitsFindData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The context or namespace to check rate limits for (e.g., a project slug or feature area).
         */
        scope?: string;
    };
    url: '/rate-limits';
};

export type RateLimitsFindErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type RateLimitsFindError = RateLimitsFindErrors[keyof RateLimitsFindErrors];

export type RateLimitsFindResponses = {
    /**
     * Success
     */
    200: {
        remaining?: number;
        reset?: number;
        limit: number;
    };
};

export type RateLimitsFindResponse = RateLimitsFindResponses[keyof RateLimitsFindResponses];

export type UserGetData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/user';
};

export type UserGetErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type UserGetError = UserGetErrors[keyof UserGetErrors];

export type UserGetResponses = {
    /**
     * Success
     */
    200: UserDetail;
};

export type UserGetResponse = UserGetResponses[keyof UserGetResponses];

export type UserGetBillingData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filters billing data by a specific scope, such as a project ID or slug.
         */
        scope?: string;
    };
    url: '/user/billing';
};

export type UserGetBillingErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type UserGetBillingError = UserGetBillingErrors[keyof UserGetBillingErrors];

export type UserGetBillingResponses = {
    /**
     * Success
     */
    200: {
        billingType: 'token';
        data: {
            plan: string;
            billingMode?: 'test';
            role: string;
            billingCycle: {
                start: number;
                end: number;
            };
            balance: {
                remaining: number;
                total: number;
            };
            onDemand: {
                balance: number;
                blocks?: Array<{
                    expirationDate?: number;
                    effectiveDate: number;
                    originalBalance: number;
                    currentBalance: number;
                }>;
            };
        };
    } | {
        billingType: 'legacy';
        data: {
            remaining?: number;
            reset?: number;
            limit: number;
        };
    };
};

export type UserGetBillingResponse = UserGetBillingResponses[keyof UserGetBillingResponses];

export type UserGetPlanData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/user/plan';
};

export type UserGetPlanErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type UserGetPlanError = UserGetPlanErrors[keyof UserGetPlanErrors];

export type UserGetPlanResponses = {
    /**
     * Success
     */
    200: {
        object: 'plan';
        plan: string;
        billingCycle: {
            start: number;
            end: number;
        };
        balance: {
            remaining: number;
            total: number;
        };
    };
};

export type UserGetPlanResponse = UserGetPlanResponses[keyof UserGetPlanResponses];

export type UserGetScopesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/user/scopes';
};

export type UserGetScopesErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type UserGetScopesError = UserGetScopesErrors[keyof UserGetScopesErrors];

export type UserGetScopesResponses = {
    /**
     * Success
     */
    200: {
        object: 'list';
        data: Array<ScopeSummary>;
    };
};

export type UserGetScopesResponse = UserGetScopesResponses[keyof UserGetScopesResponses];

export type ReportsGetUsageData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Query parameter "startDate"
         */
        startDate?: string;
        /**
         * Query parameter "endDate"
         */
        endDate?: string;
        /**
         * Query parameter "chatId"
         */
        chatId?: string;
        /**
         * Query parameter "messageId"
         */
        messageId?: string;
        /**
         * Query parameter "limit"
         */
        limit?: number;
        /**
         * Base64 encoded cursor containing pagination data
         */
        cursor?: string;
    };
    url: '/reports/usage';
};

export type ReportsGetUsageErrors = {
    /**
     * Unauthorized
     */
    401: UnauthorizedError;
    /**
     * Forbidden
     */
    403: ForbiddenError;
    /**
     * Not Found
     */
    404: NotFoundError;
    /**
     * Conflict
     */
    409: ConflictError;
    /**
     * Payload Too Large
     */
    413: PayloadTooLargeError;
    /**
     * Unprocessable Entity
     */
    422: UnprocessableEntityError;
    /**
     * Too Many Requests
     */
    429: TooManyRequestsError;
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type ReportsGetUsageError = ReportsGetUsageErrors[keyof ReportsGetUsageErrors];

export type ReportsGetUsageResponses = {
    /**
     * Success
     */
    200: {
        object: 'list';
        data: Array<{
            id: string;
            object: 'usage_event';
            type?: 'image_generation' | 'message' | 'manual_debit' | 'api_request' | 'inline-edit';
            promptCost?: string;
            completionCost?: string;
            totalCost: string;
            chatId?: string;
            messageId?: string;
            userId?: string;
        }>;
        pagination: {
            hasMore: boolean;
            nextCursor?: string;
            nextUrl?: string;
        };
        meta: {
            totalCount: number;
        };
    };
};

export type ReportsGetUsageResponse = ReportsGetUsageResponses[keyof ReportsGetUsageResponses];
